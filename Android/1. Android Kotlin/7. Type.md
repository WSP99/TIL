- 자바에서는 데이터를 **원시 타입**(Primitive Type)과 **참조 타입**(Reference Type)으로 나눌 수 있다.   
    - **원시타입** : 정수, 실수, 문자, 논리 리터럴 등의 **실제 데이터 값을 저장하는 타입**
    - **참조타입** : 객체의 번지를 참조하는 타입으로 **메모리 번지를 통해 객체를 참조하는 타입**  
    (원시타입을 제외한 타입들로 문자열, 배열, 열거, 클래스, 인터페이스를 말한다.)
- Java에서 실제 객체는 힙 영역에 저장되며, 참조 타입 변수는 스택 영역에 실제 객체들의 주소를 저장하여,   
  객체를 사용할 때마다 참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식이다.  
![image](https://user-images.githubusercontent.com/29484377/140968000-dfad6117-fa97-4264-b899-357fb9fd4e09.png)  
- 원시타입은 2가지의 장점을 가지고 있다.   
  
    **1. 접근속도**
    - 위 그림에서 봤던 것처럼 원시타입은 '스택'메모리에 값이 존재한다. 
    - 참조 타입은 하나의 인스턴스이기 때문에 스택메모리에는 참조값만 있고, 실제 값은 힙 메모리에 존재한다.
    - 그러니 값이 필요할 때마다 언박싱을 거쳐야 하므로 원시타입과 비교하여 접근속도가 느려지게 된다.  
      
    **2. 메모리 양**  
      
    ![image](https://user-images.githubusercontent.com/29484377/140970480-64ebf5b9-b979-43e1-98ee-230a3fe8dffd.png)
    - 원시 타입보다 참조 타입이 사용하는 메모리의 양이 압도적으로 높다.   
    - 왜냐하면 Integer 등의 클래스는 number 클래스를 상속받고, number 클래스는 object 클래스를 상속을 받아 차지하는 메모리 크기가 커지게 된다.
 ``` Java
 int i1 = 10
 Integer i2 = new Integer(10);
 
 HashMap<String, Integer>map = new HashMap<String, Integer>();
 map.put("ABC",i1);
 map.put("DEF",i2);
 ```
- 그럼에도 object로 값을 저장하여 사용하는 이유는 자바에서 데이터를 넣을 때 객체로 삽입되기 때문이다.
- 위 소스에서 map 변수에 primitive 타입과 object 타입으로 넣었지만 primitive 타입을 사용하여도 내부적으로는 Instance화하여 데이터를 넣게 된다.
  (i1이 객체화 되어 map에 삽입되게 됨.)
